@using UIComponents.Abstractions.Attributes;
@using UIComponents.Abstractions.Interfaces;
@using UIComponents.Abstractions.Interfaces.ExternalServices;
@using UIComponents.Abstractions.Models;
@using UIComponents.Abstractions.Extensions;
@using UIComponents.Defaults;
@using UIComponents.Defaults.Models.Graphs
@using UIComponents.Models;
@using UIComponents.Models.Models;
@using UIComponents.Models.Models.Actions;
@using UIComponents.Models.Models.Buttons;
@using UIComponents.Models.Models.Card;
@using UIComponents.Models.Models.Graphs.TimeLineGraph;
@using UIComponents.Models.Models.Dropdown;
@using UIComponents.Models.Models.Icons;
@using UIComponents.Models.Models.Inputs;
@using UIComponents.Models.Models.Texts;
@using UIComponents.Web.Extensions;


@using static UIComponents.Models.Models.Graphs.TimeLineGraph.UICTimeLineGraph;


@inject IUicLanguageService L

@model UICTimeLineGraph

@{
    string guid = Model.GetId();

    Model.AssignCollectionForChildren();

    (string LineColor, string BackgroundColor) GetColors(int index)
    {
        if (!Model.LineColors.Any())
            return (null, null);

        int colorPresetCount = Model.LineColors.Count();

        int presetIndex = index % colorPresetCount;

        return Model.LineColors[presetIndex];
    }


    Model.AddScript(
    @<text>

    function NYI(){
        console.log('This method has not yet been implemented!');
    }

    $('#@guid').on('uic-help', function(){
        console.log("Chart $('#@guid').trigger('uic-reload')", "Reload all graphs with a data source");
        console.log("Chart $('#@guid').trigger('uic-reload', 'graphId', ignoreCache=false)", "Reload this graph. If cache is enabled, you can choose to ignore the cache");
        console.log("Chart $('#@guid').trigger('uic-resize')", "ReRender the graph to scale for the available space")

        console.log("Chart $('#@guid').triggerHandler('uic-getChart')", "Returns the current graph config");
        console.log("Chart $('#@guid').triggerHandler('uic-getGraphs')", "Returns a array of all current graphs");

        let example ={
            id: 'Unique string',
            label: 'string',
            data:[{
            v: 123,
            d:"DateTime.ToString('s')",
            Id: 'Optional string'
            }],
            source: '/Home/GetData',

        };
        console.log("Chart $('#@guid').trigger('uic-addGraph', graph)", "Add a new chart clientSide, Example:", example, $.extend({}, example,defaultGraph));
        console.log("Chart $('#@guid').trigger('uic-removeGraph', 'graphId')", "Remove a graph from chart based on its Id");
        console.log("Chart $('#@guid').trigger('uic-enableGraph', 'graphId')", "If this graph is off, turn it on");
        console.log("Chart $('#@guid').trigger('uic-disableGraph', 'graphId')", "If this graph is on, turn it off");
        console.log("Chart $('#@guid').trigger('uic-toggleGraph', 'graphId')", "Turn this graph on or off");
        console.log("chart $('#@guid').trigger('uic-toggleNowIndicator', TrueFalseNull)", "Turn the now Indicator on or off. value null is toggle");

        console.log("Chart $('#@guid').on('uic-chartMoved', (ev, chart, momentStart, momentEnd) => {})", "Triggered if the chart moves or scales");
        console.log("Chart $('#@guid').on('uic-loaded', (ev, graph) => {})", "Triggered after one or more graphs have loaded data");
        console.log("Chart $('#@guid').on('uic-graphChanged', (ev, graph) => {})", "Triggered after a chart has been turned on or off");
    });

    
    $('#@guid').on('uic-reload', function(ev, graphId, ignoreCache){
        ev.stopPropagation();
        if(graphId!= undefined){
            let graph = graphs[graphId];
            if(graph == undefined)
                return;

            if(ignoreCache == true)
                graph.ranges = [];

            LoadNewGraphData(graph.id);
        } else{
            reloadAllGraphData();
        } 
    });
    $('#@guid').on('uic-resize', function(){
        OnWindowResized();
    });

    $('#@guid').on('uic-getChart', function(ev){
        ev.stopPropagation();
        console.log('chart', chart);
        return chart;
    });
    $('#@guid').on('uic-getGraphs', function(ev){
        ev.stopPropagation();
        console.log('graphs', graphs);
        return graphs;
    });
    $('#@guid').on('uic-addGraph', function(ev, graph){
        ev.stopPropagation();
        graph = $.extend({}, defaultGraph, graph);
        

        let graphId= graph.id;
        if(graphs[graphId] != undefined)
            throw `Graph with Id ${graphId} already exists`;

        graphs[graphId] = graph;
        let colorSet = graphColors[Object.getOwnPropertyNames(graphs).length%graphColors.length];
        if(graph.backgroundColor == undefined)
            graph.backgroundColor = graph.borderColor || colorSet.backgroundColor;
        if(graph.borderColor == undefined)
            graph.borderColor = colorSet.lineColor;

        syncDataSets();
        if(graph.enabled == false){
            setDataSetVisibility(graphId, false);
        } else{
            graph.enabled = true;
            LoadNewGraphData(graphId);
            chart.update('none');
            DrawNowLineRecursive();
        }
    });
    $('#@guid').on('uic-removeGraph', function(ev, graphId){
        ev.stopPropagation();
        graphs[graphId] = undefined;
        syncDataSets();
        chart.update('none');
        DrawNowLineRecursive();

    });
    $('#@guid').on('uic-enableGraph', function(ev, graphId){
        ev.stopPropagation();
        setDataSetVisibility(graphId, false);
    });
    $('#@guid').on('uic-disableGraph', function(ev, graphId){
        ev.stopPropagation();
        setDataSetVisibility(graphId, false);
    });

    $('#@guid').on('uic-toggleGraph', function(ev, graphId){
        ev.stopPropagation();
        setDataSetVisibility(graphId, null);
    });

    $('#@guid').on('uic-toggleNowIndicator', function(ev, setState = null){
        if(setState == null)
            setState = !enableDrawNowLine;
        enableDrawNowLine = setState;
        if(enableDrawNowLine)
            DrawNowLineRecursive();
        else
            chart.render();
    });

    function log(...rest){
        if(@Json.Serialize(Model.EnableConsoleLog))
            console.log('TimelineGraph @Model.GetId()', rest);
    }
    let liveUpdate = @Json.Serialize(Model.EnableLiveData);
    @if (Model.EnableLiveData)
    {
        if(!Model.LineGraphs.Where(x=>!string.IsNullOrWhiteSpace(x.Source) && x.DisableFutureLoading).Any())
        {
            <text>
            log('Live update disabled - No graphs with "@nameof(UICTimeLineGraph.LineGraph.Source)" and "@nameof(UICTimeLineGraph.LineGraph.DisableFutureLoading)");
            </text>      
        }
    }


    let graphs = {};
    let datasets= [];
    let defaultGraph = {
        pointRadius: @LineGraphDefaults.PointRadius.ToString().Replace(",","."),
        pointHitRadius: @LineGraphDefaults.PointHitRadius.ToString().Replace(",","."),
        borderWidth: @LineGraphDefaults.BorderWidth.ToString().Replace(",","."),
        tension: @LineGraphDefaults.Tension.ToString().Replace(",","."),
        fill: @Json.Serialize(LineGraphDefaults.Fill),
        stepped: @Json.Serialize(LineGraphDefaults.Stepped),
        enabled: @Json.Serialize(LineGraphDefaults.Enabled),
        cached: @Json.Serialize(LineGraphDefaults.CacheData),
        removeCacheOnZoom: @Json.Serialize(LineGraphDefaults.RemoveCacheOnZoom),
        disableFutureLoading: @Json.Serialize(LineGraphDefaults.DisableFutureLoading),

    };
    let graphColors=[
    @foreach(var colorSet in Model.LineColors){
        <text>
        {
            lineColor: @Html.JsEncode(colorSet.LineColor,"'"),
            backgroundColor: @Html.JsEncode(colorSet.BackgroundColor, "'")
        },
        </text>
    }];
    function syncDataSets(){
        datasets = [];
        EachGraph(graph =>{
            graph.index = datasets.length;
            datasets.push({
                label: graph.label,
                data: graph.data,
                stepped: graph.stepped,
                fill: graph.fill,
                pointRadius: graph.pointRadius,
                pointHitRadius: graph.pointHitRadius,
                borderColor: graph.borderColor,
                borderWidth: graph.borderWidth,
                backgroundColor: graph.backgroundColor,
                tension: graph.tension,
            });
        });
        if(chart != null)
            chart.data.datasets = datasets;
    }
    let autoInterval = @Model.LoadLiveDataMinInterval.TotalMilliseconds;
    @for(int i=0; i<Model.LineGraphs.Count; i++)
    {
        var graph = Model.LineGraphs[i];

        var colors = GetColors(i);

        if (string.IsNullOrEmpty(graph.BackgroundColor))
            graph.BackgroundColor = colors.BackgroundColor;
        if (string.IsNullOrEmpty(graph.LineColor))
            graph.LineColor = colors.LineColor;


        if (string.IsNullOrWhiteSpace(graph.LineGraphId))
            throw new Exception($"Id is required for linegraph - {await L.Translate(graph.Label)}");

        <text>
        graphs[@Html.JsEncode(graph.LineGraphId, "'")] = {
            label: @await Html.Translate(L, graph.Label),
            data: @Json.Serialize(graph.Points),
            stepped: @Json.Serialize(graph.Stepped),
            fill: @Json.Serialize(graph.Fill),
            pointRadius: @graph.PointRadius,
            pointHitRadius: @graph.PointHitRadius,
            borderColor: @Html.JsEncode(graph.LineColor, "'"),
            borderWidth: @graph.BorderWidth.ToString().Replace(",","."),
            backgroundColor: @Html.JsEncode(graph.BackgroundColor, "'"),
            tension: @Json.Serialize(graph.Tension),
            id: @Html.JsEncode(graph.LineGraphId,"'"),
            index: @Json.Serialize(i),
            enabled: @Json.Serialize(graph.Enabled),
            cached: @Json.Serialize(graph.CacheData),
            removeCacheOnZoom: @Json.Serialize(graph.RemoveCacheOnZoom),
            source: @Html.JsEncode(graph.Source,"'"),
            disableFutureLoading: @Json.Serialize(graph.DisableFutureLoading),
            additionalPostData: @Json.Serialize(graph.AdditionalPostData),
            ranges: []
        };
        

        </text>
        if (graph.Points.Any())
        {
            DateTime firstPoint = graph.Points.Select(x => x.DateTime).Min();
            DateTime lastPoint = graph.Points.Select(x => x.DateTime).Max();
            <text>
            graphs[@Html.JsEncode(graph.LineGraphId, "'")].Ranges.push({
                start: moment(@Html.JsEncode(firstPoint.ToString("s"), "'")),
                end: moment(@Html.JsEncode(lastPoint.ToString("s"), "'"))
            });
        </text>
        }
    }
    let minDateTime = @Model.Start.ToMoment(Html); //The smallest position on the current timeline
    let maxDateTime = @Model.End.ToMoment(Html); //The largest position on the current timeline
    let chart;

        syncDataSets();

    function Destroy(){
        if(!chart)
            return;
        chart.destroy();
    }
    function Initialize(){
        chart = new Chart($('#@guid')[0], {
        type: 'line',
        
        
        data:{
            datasets: datasets,
        },

        options:{
            responsive: true,
            maintainAspectRatio: false,
            parsing: {
                xAxisKey: 'd',
                yAxisKey: 'v'
            },

            scales: {
                x: {
                    min: minDateTime,
                    max: maxDateTime,
                    type: 'time',
                    time: {
                        displayFormats:{
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatDay))
                            {
                            <text>
                                day: @Html.JsEncode(Model.DisplayFormatDay, "'"),
                            </text>
                            }
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatHour))
                            {
                            <text>
                                hour: @Html.JsEncode(Model.DisplayFormatHour, "'"),
                            </text>
                            }
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatMinute))
                            {
                            <text>
                                minute: @Html.JsEncode(Model.DisplayFormatMinute, "'"),
                            </text>
                            }
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatSecond))
                            {
                            <text>
                                second: @Html.JsEncode(Model.DisplayFormatSecond, "'"),
                            </text>
                            }
                        }
                    },
                    ticks: {
                        major: {
                            enabled: @Json.Serialize(!string.IsNullOrEmpty(Model.ColorMajor)),
                        },
                        color: (context) => context.tick && context.tick.major && @Html.JsEncode(Model.ColorMajor, "'"),
                        font: function (context) {
                            if (context.tick && context.tick.major) {
                                return {
                                    weight: 'bold'
                                };
                            }
                        }
                    }

                },
            },

        
            plugins:{
                legend: {
                    onClick:(ev, legendItem, legend) => {
                        let graph;
                        EachGraph(g => {
                            if(g.index == legendItem.datasetIndex)
                                graph = g;
                        })
                        setDataSetVisibility(graph.id, null);
                    },
                    display: @Json.Serialize(Model.ShowLegend),
                    position: @Html.JsEncode(Model.LegendPosition.ToString().ToLower(), "'")
                },
                title:{
                    display: false,
                },
                zoom:
                {
                    limits:{
                        x:{
                            @if (Model.MinStart.HasValue)
                            {
                                <text>min: @Model.MinStart.Value.ToMoment(Html),</text>
                            }
                            @if (Model.MaxEnd.HasValue)
                            {
                                <text>max: @Model.MaxEnd.Value.ToMoment(Html),</text>
                            }
                        }
                    },
                    pan: {
                        enabled: @Json.Serialize(Model.EnablePanning),
                        mode: 'x',
                        onPanComplete: startFetch,
                    },
                    zoom: {

                        wheel: {
                            enabled: @Json.Serialize(Model.EnableZoom),
                        },
                        pinch: {
                            enabled: @Json.Serialize(Model.EnableZoom),
                        },
                        mode: 'x',
                        onZoomComplete: startFetch,
                        onZoomStart: (args)=>{
                            var range = args.chart.scales.x.max - args.chart.scales.x.min;
                            @*args.deltaY is the scroll direction*@
                            @if (Model.ZoomInLimit.HasValue)
                            {
                                <text> 
                                if(0 > args.event.deltaY  && @Model.ZoomInLimit.Value.TotalMilliseconds >= range)
                                    return false;
                                </text>
                            }
                            @if (Model.ZoomOutLimit.HasValue)
                            {
                                <text>
                                    if(args.event.deltaY > 0 && range >= @Model.ZoomOutLimit.Value.TotalMilliseconds)
                                    return false;
                                </text>
                            }

                            return true;
                            }
                        },
                    },
                
                },
            },
        });
    }
    
    Initialize();

    minDateTime = moment(chart.scales.x.min);
    maxDateTime = moment(chart.scales.x.max);

    let enableDrawNowLine = @Json.Serialize(Model.EnableNowIndicator);
    let drawLineInterval = 100;
    var graphsIds;
    async function startFetch({ chart }) {
        let { min, max } = chart.scales.x;

        minDateTime= moment(min);
        maxDateTime= moment(max);
        DrawNowLine();
        uic.delayedAction.run('chart-fetch-data-@guid', 1000,async ()=>{
            var startdate = moment(min);
            var enddate = moment(max);
            chart.stop(); // make sure animations are not running
            await LoadNewData(startdate, enddate);
            drawLineInterval = (maxDateTime-minDateTime)/1000;
            if(100 > drawLineInterval)
                drawLineInterval = 100;
            DrawNowLineRecursive();
            $('#@guid').trigger('uic-chartMoved', chart, minDateTime, maxDateTime);
        });
        
    };

    function LoadNewData(newMin, newMax) {
        if (newMax > moment()) {
            var newDelay = (newMax - newMin) / 100; //set miliseconds for autoupdate
            if(@Model.LoadLiveDataMinInterval.TotalMilliseconds > newDelay)
                newDelay = @Model.LoadLiveDataMinInterval.TotalMilliseconds;
            if (newDelay != autoInterval) {
                autoInterval = newDelay;
                log('Autoupdate data will happen every ' + autoInterval / 1000 + ' seconds');
            }
            AutoloadData();

        }
        else if (autoInterval != 0) {
            log('Data will not automatically update');
        }
        
        EachGraph(function(graph){
            LoadNewGraphData(graph.id, newMin, newMax);
        });
    }

    function AutoloadData() {
        if (autoInterval > 0 && liveUpdate) {
            setTimeout(async function() {
                await LoadNewData(moment(chart.scales.x.min), moment(chart.scales.x.max));
            }, autoInterval);
        }
    }

    function reloadAllGraphData(){
        EachGraph((graph) => {

            if(!graph.source.length)
                return;

            graph.ranges = [];
            LoadNewGraphData(graph.id);
        });
    }
    function setDataSetVisibility(graphId, visible){
        let graph = graphs[graphId];
        if(visible == null)
            visible = !graph.enabled;
        chart.setDatasetVisibility(graph.index, visible);
        graph.enabled = visible;
        if(visible)
            LoadNewGraphData(graphId);

        chart.update();
        DrawNowLineRecursive();
        $('#@guid').trigger('uic-graphChanged', graph);
    }
    function LoadNewGraphData(graphId, newMin, newMax){
        let graphData = graphs[graphId];
        
        if(graphData == undefined){
            console.error(`graph ${graphId} does not exist`);
            return;
        }
        
        if (!graphData.source.length)
            return;

        if(!graphData.enabled)
            return;

        if(newMin == null || minDateTime > moment(newMin))
            newMin = minDateTime;

        if(newMax == null || moment(newMax) > maxDateTime)
        newMax = maxDateTime;

        //Set the max time to now if futureloading is disabled
        if(graphData.disableFutureLoading && newMax > moment())
            newMax = moment();
        let scaleInMiliseconds;
        if(chart.scales.x.ticks.length > 1){
            scaleInMiliseconds = Math.floor(chart.scales.x.ticks[1].value - chart.scales.x.ticks[0].value);
        } else{
            scaleInMiliseconds = moment.duration(newMax - newMin)._milliseconds/60;
        }
             
        
        if(!graphData.cached){
            graphData.ranges = [];
            graphData.data=[];
        }
        else if(graphData.removeCacheOnZoom){
            if(graphData.cachedScale != scaleInMiliseconds){
                graphData.ranges = [];
                graphData.data=[];
                graphData.cachedScale = scaleInMiliseconds;
            }
        }
        //add a list of request ranges
        let requestRanges = [];

        let existingDataRanges = graphData.ranges;

        //If there is already data for this full range, do not send a new request
        let existingRange = graphData.ranges.filter(x=>x.start <= newMin && x.end >= newMax);
        if(existingRange.length)
            return;

        //If data exists at start, move start to end of existing
        let existingStart = graphData.ranges.filter(x => x.start <= newMin && x.end > newMin);
        if(existingStart.length){
            newMin = existingStart[0].end;

            let existingStartIndex = graphData.ranges.indexOf(existingStart[0]);
            graphData.ranges.splice(existingStartIndex, 1);

        }
            
        
        let existingEnd = graphData.ranges.filter(x=>x.start <newMax && x.end >= newMax);
        if(existingEnd.length){
            newMax = existingEnd[0].start;

            let existingEndIndex = graphData.ranges.indexOf(existingEnd[0]);
            graphData.ranges.splice(existingEndIndex, 1);
        }

        let includedRanges = graphData.ranges.filter(x=>x.start >= newMin && x.end<=newMax).forEach((range) =>{
            let index = graphData.ranges.indexOf(range);
            graphData.ranges.splice(index, 1);
        });
        requestRanges.push({
            start: newMin,
            end: newMax
        });
        graphData.ranges.push({
            start: existingStart[0]?.start || newMin,
            end: existingEnd[0]?.end || newMax
        });

        
        //Todo : generate requestRanges

        requestRanges.forEach(async function(range){
            let sendData= {
                StartUTC: range.start.format(),
                EndUTC: range.end.format(),
                LineGraphId: graphData.id,
                _scaleInMilliseconds: scaleInMiliseconds,
                AdditionalPostData: graphData.additionalPostData
            };
            // try{
            //     sendData._scaleInMilliseconds= 
            // }catch{}
            let result = await uic.getpost.post(graphData.source, sendData);

            log('fetch data', {
                start: range.start.format(),
                end: range.end.format(),
                data: result});

            let dataset = chart.data.datasets[graphData.index].data;
            let dataBeforeRange = dataset.filter(x => range.start > moment(x.d));
            let dataAfterRange = dataset.filter(x => moment(x.d) > range.end);

            let newData = [];
            newData = newData.concat(dataBeforeRange);
            newData = newData.concat(result);
            newData = newData.concat(dataAfterRange);

            graphData.data = newData;

            chart.data.datasets[graphData.index].data = newData;
            chart.update('none');
            DrawNowLineRecursive();
            $('#@guid').trigger('uic-loaded', graphData);
        });
    }

    function EachGraph(func){
        let propNames = Object.getOwnPropertyNames(graphs);
        propNames.forEach(function(prop){
            let graph = graphs[prop];
            if(graph == undefined)
                return;
            func(graph);
        });
    }
            setTimeout(reloadAllGraphData, 10);

        let resizeHandle = null;
        $(window).resize(() => {
            clearTimeout(resizeHandle);
            resizeHandle = setTimeout(OnWindowResized, 250);
        });

        function OnWindowResized() {
            Destroy();
            Initialize();
        }

        
        let drawLineDelay = null;
        function DrawNowLineRecursive(){
            if(drawLineDelay != null)
                clearTimeout(drawLineDelay);

            DrawNowLine();
            drawLineDelay = setTimeout(()=>{
                DrawNowLineRecursive();
            }, drawLineInterval);
        };
        function DrawNowLine(){
            if(!enableDrawNowLine)
                return;

            let context = chart.ctx;
            let lineLeftOffset = GetLeftPosition(moment());
            if(lineLeftOffset == null)
                return;

            chart.render();
            let scale = chart.scales.y;
            context.beginPath();
            context.strokeStyle = @Html.JsEncode(Model.NowIndicatorColor, "'");
            context.moveTo(lineLeftOffset, scale.top);
            context.lineTo(lineLeftOffset, scale.bottom);
            context.stroke();
        };
        function GetLeftPosition(momentTime){
            let scale = chart.scales.x;
            let width = scale.width;
            let momentValue = momentTime.valueOf();
            let max = scale.max;
            if(momentValue > max)
                return null;

            let min = scale.min;
            if(min > momentValue)
                return null;

            let range = max-min;
            let fromStart = momentValue - min;
            let percent = fromStart / range;
            let pixelsLeft = scale.left + (width * percent);
            return Math.round(pixelsLeft);
        };
            DrawNowLineRecursive();
    </text>);
}

<div class="flex-grow-1" style="width: @Html.JsEncode(Model.Width); height: @Html.JsEncode(Model.Height); max-height:@Html.JsEncode(Model.MaxHeight)">
    <canvas @Html.Raw(Model.GetHtmlAttributes())>
    </canvas>
</div>


@if (!string.IsNullOrEmpty(Model.Script_ChartJs))
{
    <script src="@Model.Script_ChartJs"></script>
}
@if (!string.IsNullOrEmpty(Model.Script_HammerJs))
{
    <script src="@Model.Script_HammerJs"></script>
}
@if (!string.IsNullOrEmpty(Model.Script_ChartJs_Adapter_Moment))
{
    <script src="@Model.Script_ChartJs_Adapter_Moment"></script>
}
@if (!string.IsNullOrEmpty(Model.Script_ChartJs_Plugin_Zoom))
{
    <script src="@Model.Script_ChartJs_Plugin_Zoom"></script>
}


@await Model.RenderStylesAndScripts(Component)