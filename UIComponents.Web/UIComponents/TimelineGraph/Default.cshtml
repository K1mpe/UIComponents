@using UIComponents.Abstractions.Attributes;
@using UIComponents.Abstractions.Interfaces;
@using UIComponents.Abstractions.Interfaces.ExternalServices;
@using UIComponents.Abstractions.Models;
@using UIComponents.Abstractions.Extensions;
@using UIComponents.Defaults;
@using UIComponents.Models;
@using UIComponents.Models.Models;
@using UIComponents.Models.Models.Actions;
@using UIComponents.Models.Models.Buttons;
@using UIComponents.Models.Models.Card;
@using UIComponents.Models.Models.Graphs.TimeLineGraph;
@using UIComponents.Models.Models.Dropdown;
@using UIComponents.Models.Models.Icons;
@using UIComponents.Models.Models.Inputs;
@using UIComponents.Models.Models.Texts;
@using UIComponents.Web.Extensions;


@using static UIComponents.Models.Models.Graphs.TimeLineGraph.UICTimeLineGraph;


@inject IUicLanguageService L

@model UICTimeLineGraph

@{
    string guid = Model.GetOrGenerateId();

    Model.AssignCollectionForChildren();

    (string BackgroundColor, string LineColor) GetColors(int index)
    {
        if (!Model.LineColors.Any())
            return (null, null);

        int colorPresetCount = Model.LineColors.Count();

        int presetIndex = index % colorPresetCount;

        return Model.LineColors[presetIndex];
    }


    Model.AddScript(
    @<text>

    function NYI(){
        console.log('This method has not yet been implemented!');
    }

    $('#@guid').on('help', function(){
        console.log("Chart $('#@guid').trigger('uic-reload')", "Reload all graphs with a data source");
        console.log("Chart $('#@guid').trigger('uic-reload', 'graphId')", "Reload this graph");
        console.log("Chart $('#@guid').trigger('uic-resize')", "ReRender the graph to scale for the available space")

        console.log("Chart $('#@guid').triggerHandler('uic-getChart')", "Returns the current graph config");
        console.log("Chart $('#@guid').triggerHandler('uic-getGraphs')", "Returns a array of all current graphs");

        console.log("Chart $('#@guid').trigger('uic-addGraph', graph)", "Add a new chart clientSide, Example:", {
            id: 'Unique string',
            label: 'string',
            data:[{
                v: 123,
                d:"DateTime.ToString('s')",
                Id: 'Optional string'
            }],
            source: '/Home/GetData',

        });
        console.log("Chart $('#@guid').trigger('uic-removeGraph', 'graphId')", "Remove a graph from chart based on its Id");
        console.log("Chart $('#@guid').trigger('uic-enableGraph', 'graphId')", "If this graph is off, turn it on");
        console.log("Chart $('#@guid').trigger('uic-disableGraph', 'graphId')", "If this graph is on, turn it off");
        console.log("Chart $('#@guid').trigger('uic-toggleGraph', 'graphId')", "Turn this graph on or off");


        console.log("Chart $('#@guid').on('uic-chartMoved', (ev) => {})", "Triggered if the chart moves or scales");
        console.log("Chart $('#@guid').on('uic-loaded', (ev, loadedData) => {})", "Triggered after one or more graphs have loaded data");
        console.log("Chart $('#@guid').on('uic-graphChanged', (ev, changedData) => {})", "Triggered after a chart has been turned on or off");
    });

    $('#@guid').on('uic-reload', function(ev, graphId){
        ev.stopPropagation();
        if(graph.length){
            NYI();
        } else{
            reloadAllGraphData();
        } 
    });
    $('#@guid').on('uic-resize', function(){
        OnWindowResized();
    });

    $('#@guid').on('uic-getChart', function(ev){
        ev.stopPropagation();
        console.log('chart', chart);
        return chart;
    });
    $('#@guid').on('uic-getGraphs', function(ev){
        ev.stopPropagation();
        NYI();
    });
    $('#@guid').on('uic-addGraph', function(ev, graph){
        ev.stopPropagation();
        NYI();
    });
    $('#@guid').on('uic-removeGraph', function(ev, graphId){
        ev.stopPropagation();
        NYI();
    });
    $('#@guid').on('uic-enableGraph', function(ev, graphId){
        ev.stopPropagation();
        NYI();
    });
    $('#@guid').on('uic-disableGraph', function(ev, graphId){
        ev.stopPropagation();
        NYI();
    });

    $('#@guid').on('uic-toggleGraph', function(ev, graphId){
        ev.stopPropagation();
        NYI();
    });


    function log(...rest){
        if(@Json.Serialize(Model.EnableConsoleLog))
            console.log('TimelineGraph @Model.GetOrGenerateId()', rest);
    }
    let liveUpdate = @Json.Serialize(Model.EnableLiveData);
    @if (Model.EnableLiveData)
    {
        if(!Model.LineGraphs.Where(x=>!string.IsNullOrWhiteSpace(x.Source) && x.DisableFutureLoading).Any())
        {
            <text>
            log('Live update disabled - No graphs with "@nameof(UICTimeLineGraph.LineGraph.Source)" and "@nameof(UICTimeLineGraph.LineGraph.DisableFutureLoading)");
            </text>      
        }
    }


    let graphs = {};
    let datasets= [];
    let autoInterval = @Model.LoadLiveDataMinInterval.TotalMilliseconds;
    @for(int i=0; i<Model.LineGraphs.Count; i++)
    {
        var graph = Model.LineGraphs[i];

        var colors = GetColors(i);

        if (string.IsNullOrEmpty(graph.BackgroundColor))
            graph.BackgroundColor = colors.BackgroundColor;
        if (string.IsNullOrEmpty(graph.LineColor))
            graph.LineColor = colors.LineColor;


        if (string.IsNullOrWhiteSpace(graph.LineGraphId))
            throw new Exception($"Id is required for linegraph - {await L.Translate(graph.Label)}");

        <text>
        graphs[@Html.JsEncode(graph.LineGraphId, "'")] = {
            label: @await Html.Translate(L, graph.Label),
            data: @Json.Serialize(graph.Points),
            stepped: @Json.Serialize(graph.Stepped),
            fill: @Json.Serialize(graph.Fill),
            pointRadius: @graph.PointRadius,
            borderColor: @Html.JsEncode(graph.LineColor, "'"),
            backgroundColor: @Html.JsEncode(graph.BackgroundColor, "'"),
            tension: @graph.Tension,
            id: @Html.JsEncode(graph.LineGraphId,"'"),
            index: @Json.Serialize(i),
            enabled: @Json.Serialize(graph.Enabled),
            cached: @Json.Serialize(graph.CacheData),
            source: @Html.JsEncode(graph.Source,"'"),
            disableFutureLoading: @Json.Serialize(graph.DisableFutureLoading),
            additionalPostData: @Json.Serialize(graph.AdditionalPostData),
            ranges: []
        };
        datasets.push({
            label: @await Html.Translate(L, graph.Label),
            data: @Json.Serialize(graph.Points),
            stepped: @Json.Serialize(graph.Stepped),
            fill: @Json.Serialize(graph.Fill),
            pointRadius: @graph.PointRadius,
            borderColor: @Html.JsEncode(graph.LineColor, "'"),
            backgroundColor: @Html.JsEncode(graph.BackgroundColor, "'"),
            tension: @graph.Tension,
        });

        </text>
        if (graph.Points.Any())
        {
            DateTime firstPoint = graph.Points.Select(x => x.DateTime).Min();
            DateTime lastPoint = graph.Points.Select(x => x.DateTime).Max();
            <text>
            graphs[@Html.JsEncode(graph.LineGraphId, "'")].Ranges.push({
                start: moment(@Html.JsEncode(firstPoint.ToString("s"), "'")),
                end: moment(@Html.JsEncode(lastPoint.ToString("s"), "'"))
            });
        </text>
        }
    }
                
    let minDateTime = @Model.Start.ToMoment(Html); //The smallest position on the current timeline
    let maxDateTime = @Model.End.ToMoment(Html); //The largest position on the current timeline
    let chart;

    function Initialize(){
        chart = new Chart($('#@guid')[0], {
        type: 'line',
        
        
        data:{
            datasets: datasets,
        },

        options:{
            responsive: true,
            maintainAspectRatio: true,

            parsing: {
                xAxisKey: 'd',
                yAxisKey: 'v'
            },

            scales: {
                x: {
                    min: minDateTime,
                    max: maxDateTime,
                    type: 'time',
                    time: {
                        displayFormats:{
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatDay))
                            {
                            <text>
                                day: @Html.JsEncode(Model.DisplayFormatDay, "'"),
                            </text>
                            }
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatHour))
                            {
                            <text>
                                hour: @Html.JsEncode(Model.DisplayFormatHour, "'"),
                            </text>
                            }
                            @if (!string.IsNullOrEmpty(Model.DisplayFormatMinute))
                            {
                            <text>
                                minute: @Html.JsEncode(Model.DisplayFormatMinute, "'"),
                            </text>
                            }
                                @if (!string.IsNullOrEmpty(Model.DisplayFormatSecond))
                            {
                            <text>
                                second: @Html.JsEncode(Model.DisplayFormatSecond, "'"),
                            </text>
                            }
                        }
                    },
                    ticks: {
                        major: {
                            enabled: true
                        },
                        color: (context) => context.tick && context.tick.major && '#FF0000',
                        font: function (context) {
                            if (context.tick && context.tick.major) {
                                return {
                                    weight: 'bold'
                                };
                            }
                        }
                    }

                },
            },

        
            plugins:{
                legend: {
                    display: @Json.Serialize(Model.ShowLegend),
                    position: @Html.JsEncode(Model.LegendPosition.ToString().ToLower(), "'")
                },
                title:{
                    display: false,
                },
                zoom:
                {
                    limits:{
                        x:{
                            @if (Model.MinStart.HasValue)
                            {
                                <text>min: @Model.MinStart.Value.ToMoment(Html),</text>
                            }
                            @if (Model.MaxEnd.HasValue)
                            {
                                <text>max: @Model.MaxEnd.Value.ToMoment(Html),</text>
                            }
                        }
                    },
                    pan: {
                        enabled: @Json.Serialize(Model.EnablePanning),
                        mode: 'x',
                        onPanComplete: startFetch,
                    },
                    zoom: {

                        wheel: {
                            enabled: @Json.Serialize(Model.EnableZoom),
                        },
                        pinch: {
                            enabled: @Json.Serialize(Model.EnableZoom),
                        },
                        mode: 'x',
                        onZoomComplete: startFetch,
                        onZoomStart: (args)=>{
                            var range = args.chart.scales.x.max - args.chart.scales.x.min
                            console.log('checkzoom');
                            @*args.deltaY is the scroll direction*@
                            @if (Model.ZoomInLimit.HasValue)
                            {
                                <text> 
                                if(0 > args.event.deltaY  && @Model.ZoomInLimit.Value.TotalMilliseconds >= range)
                                    return false;
                                </text>
                            }
                            @if (Model.ZoomOutLimit.HasValue)
                            {
                                <text>
                                    if(args.event.deltaY > 0 && range >= @Model.ZoomOutLimit.Value.TotalMilliseconds)
                                    return false;
                                </text>
                            }

                            return true;
                            }
                        },
                    },
                
                },
            },
        });
    }
    
    Initialize();

    minDateTime = moment(chart.scales.x.min);
    maxDateTime = moment(chart.scales.x.max);

    var graphsIds;
    async function startFetch({ chart }) {
        let { min, max } = chart.scales.x;

        minDateTime= moment(min);
        maxDateTime= moment(max);
        uic.delayedAction.run('chart-fetch-data-@guid', 1000,async ()=>{
            var startdate = moment(min);
            var enddate = moment(max);
            chart.stop(); // make sure animations are not running
            await LoadNewData(startdate, enddate);
        });
        $('#@guid').trigger('uic-chartMoved');
    };

    function LoadNewData(newMin, newMax) {
        if(liveUpdate){
            if (newMax > moment()) {
                var newDelay = (newMax - newMin) / 100; //set miliseconds for autoupdate
                if(@Model.LoadLiveDataMinInterval.TotalMilliseconds > newDelay)
                    newDelay = @Model.LoadLiveDataMinInterval.TotalMilliseconds;
                if (newDelay != autoInterval) {
                    autoInterval = newDelay;
                    log('Autoupdate data will happen every ' + autoInterval / 1000 + ' seconds');
                }
                AutoloadData();
            }
            else if (autoInterval != 0) {
                console.log('Data will not automatically update');
            }
        }
        
        EachGraph(function(graph){
            LoadNewGraphData(graph.LineGraphId, newMin, newMax);
        });
    }

    function AutoloadData() {
        if (autoInterval > 0) {
            setTimeout(async function() {
                await LoadNewData(moment(chart.scales.x.min), moment(chart.scales.x.max));
            }, autoInterval);
        }
    }

    function reloadAllGraphData(){
        EachGraph((graph) => {

            if(!graph.source.length)
                return;

            graph.ranges = [];
            LoadNewGraphData(graph.id);
        });
    }

    function LoadNewGraphData(graphId, newMin, newMax){
        
        let graphData = graphs[graphId];
        
        if(graphData == undefined){
            console.error(`graph ${graphId} does not exist`);
            return;
        }

        if (!graphData.source.length)
            return;

        if(!graphData.enabled)
            return;

        if(newMin == null || minDateTime > moment(newMin))
            newMin = minDateTime;

        if(newMax == null || moment(newMax) > maxDateTime)
        newMax = maxDateTime;

        //Set the max time to now if futureloading is disabled
        if(graphData.disableFutureLoading && newMax > moment())
            newMax = moment();

        //add a list of request ranges
        let requestRanges = [];

        let existingDataRanges = graphData.ranges;

        if(graphData.Cached){
            console.error('cache linegraph is not yet implemented')
        }
        else{
            chart.data.datasets[graphData.index].data = [];
            requestRanges.push({
                start: newMin,
                end: newMax
            });
        }

        
        //Todo : generate requestRanges

        requestRanges.forEach(async function(range){
            let sendData= {
                StartUTC: range.start.format(),
                EndUTC: range.end.format(),
                LineGraphId: graphData.id,
                _scaleInMilliseconds: Math.floor(chart.scales.x.ticks[1].value - chart.scales.x.ticks[0].value),
                AdditionalPostData: graphData.additionalPostData
            };
            let result = await uic.getpost.post(graphData.source, sendData);

            log('fetch data', {
                start: range.start.format(),
                end: range.end.format(),
                data: result});

            let dataset = graphData.data;
            let dataBeforeRange = dataset.filter(x => range.start > x.DateValue);
            let dataAfterRange = dataset.filter(x => range.end > x.DateValue);

            let newData = [];
            newData = newData.concat(dataBeforeRange);
            newData = newData.concat(result);
            newData = newData.concat(dataAfterRange);

            graphData.data = newData;

            graphData.ranges.push(range);
            chart.data.datasets[graphData.index].data = newData;
            chart.update('none');
        });
    }

    function EachGraph(func){
        let propNames = Object.getOwnPropertyNames(graphs);
        propNames.forEach(function(prop){
            let graph = graphs[prop];
            func(graph);
        });
    }

    reloadAllGraphData();

        let resizeHandle = null;
        $(window).resize(() => {
            clearTimeout(resizeHandle);
            resizeHandle = setTimeout(OnWindowResized, 250);
        });

        function OnWindowResized() {
            InitializeChart();
        }

    async function oldCode(){

        if (!(newMin < minValue || newMax > maxValue))
            return;

        var objects = [];
        graphsIds.forEach(item => {
            var timespans = []
            if (newMin < minValue) {
                timespans.push({ start: newMin.toISOString(true), end: minValue.toISOString(true) });
            }
            if (newMax > maxValue) {
                timespans.push({ start: maxValue.toISOString(true), end: newMax.toISOString(true) });
            }
            objects.push({ Id: item.id, Timespans: timespans });
        });

        if (newMin < minValue) {
            minValue = newMin;
            $('#daterange-start').data('daterangepicker').setStartDate(minValue);
        }

        if (newMax > maxValue) {
            maxValue = newMax;
            $('#daterange-start').data('daterangepicker').setEndDate(maxValue);
        }


        await GetGraphData(objects);

        let tHandle = null;
        $(window).resize(function() {
            if (tHandle)
                clearTimeout(tHandle);
            tHandle = setTimeout(() => {
                tHanle = null;
                Resize();
            }, 100);
        });

        function Resize(){
            createChart();
        }


        async function GetGraphData(objects, fullReload) {
            if (objects.length === 0)
        return;

        let data = {
            Requests: objects
        };


        if (fullReload)
        
        var response = await $.post('@Url.Action("LoadData", "WashingMachine")', data);
        

        if (fullReload === true)
        chart.data.datasets = response;
        else {
        chart.data.datasets.forEach(dataset => {
        var firstLoaded = dataset.data[0];
        var lastLoaded = dataset.data[dataset.data.length - 1];
        var current = response.filter(x => x.label == dataset.label)[0];

        var olderData = current.data.filter(x => x.d < firstLoaded.d);
        var newData = current.data.filter(x => x.d > lastLoaded.d);
        dataset.data = olderData.concat(dataset.data);
        dataset.data = dataset.data.concat(newData);
        });
        }
        chart.update();
    }
    //#endregion

    //Buttons
    //#region
    $('.btn-reload').click(async function() {
        toggleSidebar(false);
        Resize();
        await ReloadData();
    });

    

    //#endregion
    }
    </text>);
}

<div class="flex-grow-1" width="@Html.JsEncode(Model.Width)" height="@Html.JsEncode(Model.Height)">
    <canvas @Html.Raw(Model.GetHtmlAttributes())>
    </canvas>
</div>



<script src="~/lib/chart.js/dist/chart.umd.js"></script>
<script src="~/lib/hammerjs/hammer.min.js"></script>
<script src="~/lib/chartjs-adapter-moment/dist/chartjs-adapter-moment.js"></script>
<script src="~/lib/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.js"></script>

@await Model.RenderStylesAndScripts(Component)